---
# Supported options: 
#   sn-nature:       Style for submissions to Nature Portfolio journals
#   sn-basic:        Basic Springer Nature Reference Style/Chemistry Reference Style
#   sn-mathphys:     Math and Physical Sciences Reference Style
#   sn-aps:          American Physical Society (APS) Reference Style
#   sn-vancouver:    Vancouver Reference Style
#   sn-apa:          APA Reference Style 
#   sn-chicago:      Chicago-based Humanities Reference Style
#   default:         Default
classoptions: 
  - sn-apa      
  # - Numbered      # Optional: Use numbered references instead of namedate references (only for sn-nature, sn-basic, sn-vancouver, sn-chicago, sn-mathphys or sn-nature)
  # - referee       # Optional: Use double line spacing 
  # - lineno        # Optional: Add line numbers
  # - iicol         # Optional: Double column layour
title: Graph Databases for Behavior Science
titlerunning: Article Title runing
authors: 
  - firstname: Juan
    particle: C.
    lastname: Correa
    email: j.correa.n@gmail.com
    affiliation: [1,2]
    corresponding: TRUE
#  - firstname: Second
#    lastname: Author
#    affiliation: 2
affiliations:
    
  - number: 1
    corresponding: TRUE
    info:
      orgdiv: Departmento de Estudios Empresariales
      orgname: Universidad Iberoamericana
    address:
        city: Mexico City
        postcode: 01219
        country: Mexico
  - number: 2
    corresponding: TRUE
    info:
      orgdiv: Research and Development Unit
      orgname: Critical Centrality Institute
keywords:
  - Graph database
  - Network modeling
  - complex behavior
# abstract: |
abstract: |
  Behavioral scientists have multiple options for managing research data. While relational databases offer robust tools for storage and analysis, they impose structural constraints that limit the representation of complex behavioral phenomena. This article argues that graph databases provide a rigorous and conceptually richer alternative, enabling the modeling of human behavior as an interconnected system rather than a set of isolated variables. Beyond a technological shift, adopting graph-based approaches invites a paradigm change in behavior science—one that embraces complexity, dynamic relationships, and multi-level contingencies. Practical implications are illustrated by revisiting a database used by consumer psychologists to evaluate how traffic condition contingencies impact key performance indicators of online food delivery services.
bibliography: bibliography.bib
header-includes: |
  %% Per the spinger doc, new theorem styles can be included using built in style, 
  %% but it seems the don't work so commented below
  %\theoremstyle{thmstyleone}%
  \newtheorem{theorem}{Theorem}%  meant for continuous numbers
  %%\newtheorem{theorem}{Theorem}[section]% meant for sectionwise numbers
  %% optional argument [theorem] produces theorem numbering sequence instead of independent numbers for Proposition
  \newtheorem{proposition}[theorem]{Proposition}%
  %%\newtheorem{proposition}{Proposition}% to get separate numbers for theorem and proposition etc.
  %% \theoremstyle{thmstyletwo}%
  \theoremstyle{remark}
  \newtheorem{example}{Example}%
  \newtheorem{remark}{Remark}%
  %% \theoremstyle{thmstylethree}%
  \theoremstyle{definition}
  \newtheorem{definition}{Definition}%
output: rticles::springer_article
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      out.extra = "")  # This forces knitr to label all figures.
```

# Introduction {#sec1}

In a recent article, @soto2025 introduced relational databases and illustrated their use by behavioral scientists through real-world examples.
Although relational databases remain the dominant paradigm in research and industry, alternative approaches are gaining traction.
The so-called ‘Not Only SQL’ (NoSQL) category includes database systems that employ non-tabular data models, such as key-value pairs, documents, wide columns, matrices, and graphs.
Whereas relational databases store structured data in tables (i.e., columns as variables, rows as cases, and cells containing specific values), NoSQL systems accommodate flexible formats that better support evolving and highly connected data.

In this article, I examine graphs as a paradigm that deviates from the traditional lenses of relational databases, where nodes and edges (instead of tables and joins) represent the basic elements of any behavior that can be represented as a network or a complex system.
Networks have a long history in mathematics as "*graph theory*" [@Estrada2011].
In sociology and social sciences, graph theory is known as "social network analysis" [@Wasserman1994].
In this context, the term "social network" should not be confused with online platforms such as Facebook or Instagram, as they are technological implementations that do not necessarily represent all aspects of social networks as a discipline.
Psychologists have leveraged this framework to analyze the structure of psychopathology [@borsboom2013], conduct bibliometric analysis of cyberbehavior [@serafin2019], estimate the correct number of dimensions in psychological and educational instruments [@golino2017], or understand the measurement of organizational climate [@menezes2021].

# Network as a collection nodes and edges {#sec2}

@Estrada2011 defines a network as a collection of points (called nodes) joined together in pairs by lines (called arcs or edges) like those depicted in Figure [1](#fig:F1).
Despite this simplistic definition, networks provide a powerful framework to model any type of system from planets in a galaxy to neurons in the nervous system [@Vazza2020].

```{r F1, echo=FALSE, fig.cap="A visual representation of four types of networks: A) non-directed unweighted network, B) non-directed weighted network, C) directed unweighted network, and D) directed weighted network.", fig.align="center", out.width="380px", fig.pos="H"}
knitr::include_graphics("/home/jcc/Documents/GitHub/NOSQLINBS/F1.png")
```

In behavioral sciences, networks have been used to understand the mechanisms of team assembly and how these mechanisms determine collaboration structure and team performance [@guimera2005].
Graphs offer fundamental concepts for understanding how entities (nodes) and their relationships (edges) form interconnected structures.
From a data management viewpoint, the analysis of these networks requires tools that go beyond the rigid tabular constraints of relational databases.
As the concepts of graphs are thoroughly covered in introductory texts [@Newman2010], these will not be revisited here.
Instead, this article aims to illustrate how graph-based databases can enrich the methodological toolbox of behavioral scientists, enabling analyses that embrace complexity, dynamic relationships, and multi-level contingencies [@Robinson2015].

# Graph databases: A gentle introduction

@Robinson2015 define a graph database as a system that implements **C**reate, **R**ead, **U**pdate, and **D**elete (CRUD) operations on a graph data model, where entities are represented as nodes and relationships as edges like the one depicted in Figure [2](#fig:F2).

```{r F2, echo=FALSE, fig.cap="A visual representation of a graph database that combines persons, companies, and routes", fig.align="center", out.height="180px", out.width="350px", fig.pos="H"}
knitr::include_graphics("/home/jcc/Documents/GitHub/NOSQLINBS/F2.png")
```

Unlike relational databases, which organize data in tables, graph databases treat relationships as first-class elements rather than secondary links between tables.
This design enables efficient traversal and pattern matching across highly connected data, making it ideal for modeling complex networks such as behavioral contingencies or social interactions.
Nodes in Figure [2](#fig:F2) refers to real-world entities such as persons (i.e., Anna, Pam, Carlos, and John) companies (i.e., Chevron and Rice University), and routes (i.e., I-10 and I-45).
Edges represent the relationship between pairs of nodes.
Thus, John and Pam work in Chevron but they commute distinct distances through different routes.
Carlos and Anna work in Rice University, they both commute by the same route but they have to drive different distances.
Interestingly, the information of nodes and edges can be enriched with attributes.
These attributes also represent real-world characteristics like the distance each person has to commute, their sex, or the sector of the company they work for.

A graph database model like the one depicted in Figure [2](#fig:F2) leverages the so-called "labeled property graph" which has the following elements: 1) nodes and relationships, 2) nodes contain properties (key-value pairs), 3) nodes can be labeled with one or more labels, 4) relationships are named and directed, and always have a start and end node, 5) relationships can also contain properties.
Although these elements offer significant benefits for behavioral scientists, they have been largely overlooked.
This gap presents an opportunity to enrich the methodological toolbox for behavior analysts working in both basic and applied settings, particularly those interested in integrating methods from other disciplines into behavioral sciences.

According to @Robinson2015, one advantage of graph database models is their superior performance when handling connected data compared to relational databases that rely on tabular structures.
In relational databases, join-intensive queries slow down as datasets grow, whereas graph databases maintain relatively stable performance—even with millions of nodes and edges.
While big data challenges may not concern experimental behavior analysts working with small laboratory datasets, applied behavior analysts can benefit significantly from graph databases.
For example, consider analyzing urban traffic at an individual level by tracking the movements of hundreds of thousands of drivers every two hours [@Gonzalez2008].
In such cases, graph databases excel because queries operate on localized portions of the graph rather than scanning the entire dataset.
If edges store information such as commuting distances, queries can be designed to retrieve specific conditions (e.g., individuals who commute less than 10 miles).
Consequently, execution time depends only on the size of the subgraph traversed, not the overall graph size.

Another advantage of graph databases has to do with their flexibility.
Behavioral scientists aim to connect data in ways that reflect their knowledge and expertise.
This is why graph databases serve as the underlying infrastructure for constructing "knowledge graphs" [@Barrasa2023].
With these knowledge graphs, researchers allow the database to evolve alongside their understanding of the behavioral phenomenon rather than being rigidly defined upfront, when knowledge is most limited.
This is particularly important when a behavioral phenomenon lacks theoretical background or lacks replication [@burgos2025].
Graph databases fulfill this need by providing a flexible model that adapts to changing requirements and evidence.
Because graphs are inherently additive, new nodes, relationships, labels, and subgraphs can be introduced.
The modifications introduced to the original graph do not imply a threat to existing queries or application functionality.
This flexibility minimizes the need for exhaustive upfront modeling and lowers the frequency of costly migrations (particularly for companies that hire behavior data scientists in charge of analyzing customers observed behavior), thereby reducing maintenance overhead.

A third benefit of graph databases is the agility that they offer.
Modern graph databases enable smooth development and easy system maintenance.
Their schema-free design, combined with testable APIs and query languages, allows controlled evolution of applications.
While the absence of rigid schemas means traditional governance mechanisms are missing, this is not a drawback.
On the contrary, it encourages more transparent and actionable data governance.
Typically, governance is enforced programmatically through tests that validate data models, queries, and business rules.
This approach aligns well with agile and test-driven development practices, making graph database applications adaptable to changing business needs.

It is worth mentioning that relational databases acknowledge relationships, but only during modeling, where they serve as join mechanisms between tables.
In graph databases, we often need to clarify the meaning of relationships and even qualify their strength.
These are aspects that relational database management systems do not address explicitly [@Robinson2015].
From this viewpoint, graph databases demand ontological considerations such as those recently described for psychology and behavioral sciences [@burgos2025].
As datasets grow more complex and less uniform, relational data management systems like Microsoft Access, PostgreSQL, or SQLite become burdened with large join tables, sparsely populated rows, and extensive null-checking logic.
Greater interconnectedness in relational databases leads to more joins, which degrade performance and complicate adaptation to evolving requirements.
@soto2025 has highlighted some of these limitations as "challenges to adoption." From the lenses of graph databases, however, these challenges are not even necessary.
I will elaborate upon this particular aspect below.

# Applying graph database in behavioral research

To illustrate the application of graph databases for behavioral scientists, I revisit data from customers who used an online food delivery platform in the city of Bogotá.
The database is available in a public data repository [@segura2019] which refers to an associated research article [@correa2019a].
Behavioral scientists who are familiar with structured datasets will find that this database is in a coma-separated values (.csv) file, just like most tables used in relational database management systems like Microsoft Access or SQLite.
Given the wide variety of graph database management systems in the market (e.g., Neo4j, Microsoft Azure Cosmos, Aerospike, Amazon Web Services Neptune, NebulaGraph, Memgraph, TigerGraph, Giraph), the rest of this work relies on Neo4j [@Barrasa2023].
Neo4j ranks as the leading freemium software in the segment of graph database management systems and has been used in several industry sectors including retail, finance, pharmaceutics, hospitality, and electronic commerce, among others.
Neo4j offers free and enterprise editions, which can be installed on local or server environments following official documentation.
As the official documentation provides helpful material for newcomers, downloading and installation details are not necessary here, and the reader can consult specific details elsewhere [@vanBruggen2014].

## Instance creation and data import

Instance creation is the first step in using graph databases with Neo4j.
This is a top-level operation for setting up a new database environment, and involves allocating resources (memory, CPU, storage), defining a database version, and setting up initial user credentials by clicking one button.
When creating a new instance, neo4j asks the user to provide a name as part of the instance details.
The user is asked to provide a password of eight characters as a security check for further interactions.
The instance created is called "OFD," an acronym for "Online Food Delivery." Figure [3](#fig:F3) depicts this instance which by default is "stopped." The user should start the instance by clicking the button "Start instance" that is at the top right of the window.
This action will create two default databases (i.e., neo4j and system).

```{r F3, echo=FALSE, fig.cap="The look-and-feel of an instance created in neo4j", fig.align="center", out.height="180px", out.height="100px", out.width="380px", fig.pos="H"}
knitr::include_graphics("/home/jcc/Documents/GitHub/NOSQLINBS/F3.png")
```

Our database can be easily uploaded by moving the mouse to the left panel of neo4j and clicking on the icon "import" depicted with a red circle in Figure [4](#fig:F4).

```{r F4, echo=FALSE, fig.cap="The drag-and-drop import files option in the left panel of neo4j", fig.align="center", out.height="180px", out.height="200px", out.width="380px", fig.pos="H"}
knitr::include_graphics("/home/jcc/Documents/GitHub/NOSQLINBS/F4.png")
```

As described above, the database is a csv file (newdata.csv) with a total of 19 variables.
According to @segura2019, this database was developed with the goal of evaluating the impact of traffic conditions on key performance indicators of a sample of restaurants with food delivery services in Bogotá City.
It includes the physical location of both restaurants and customers, as well as key performance indicators and traffic descriptions captured by the Google Maps API at three time points during Saturday rush hours.

## Understanding the context

According to @correa2019a, real traffic conditions in cities like Bogotá can have an impact on how customers evaluate food delivery services such as UberEATS, Just-Eat, or ClickDelivery.
As the traffic in this city has long suffered congestion problems, local governmental authorities have decided to impose a restriction program called "Pico y Placa." As per @montero2025, this program was introduced in August 1998 and over the years the restriction has been modified several times looking to extend its scope.
For example, since July 2012, Pico y Placa affects the half of residential and commercial vehicles every other day of the week (excluding weekends) from 6:00 to 8:30 a.m.
and then from 3:00 to 7:30 p.m, and buses, police cars, ambulances, fire trucks, government and diplomatic vehicles, school buses and vans, and electric and hybrid vehicles are exempt.
To decide which half of the fleet is restricted in any given day, the Pico y Placa follows an odd–even schedule based on the last digit of the vehicle’s license plate [@montero2025].

In this context, @correa2019a reported that the data collected from Google Maps API indicated that rush hours occur three times during Saturdays: in the morning (between 8:00 and 10:00 a.m); around midday (between 12:00 and 2:00 p.m); and in the evenings (between 6:00 and 8:00 p.m).
Based on this information, @correa2019a classiﬁed the typical traﬃc in three categories: "free" or "green traﬃc" (G), "average" or "orange traﬃc" (O), and "heavy" or "red traﬃc" (R).
By using letter triads they characterized the typical daily traﬃc with sequences like "G-G-G" or "R-O-R." Thus, for example, the sequence “R-O-G” means that the typical traﬃc changes from “red” in the morning to “orange” at noon and “green” in the afternoon, describing a place where traﬃc conditions improve as time passes.

## Sketching a graph database model

Sketching a graph database model is the next step after a successful data import in Neo4j.
Given the benefits of the labeled property graph, an initial model can be modified multiple times.
These modifications are important because they reflect the analyst’s expertise and highlight critical nodes and relationships to be mapped.
An initial graph database model can consider the most elementary schema focused on the relationship between restaurants and customers (Figure [5](#fig:F5)).

```{r F5, echo=FALSE, fig.cap="A visual representation of the initial schema about restaurants-customers relationship", fig.align="center", out.height="180px", out.height="100px", out.width="380px", fig.pos="H"}
knitr::include_graphics("/home/jcc/Documents/GitHub/NOSQLINBS/F5.png")
```

In this graph model, the node "Restaurant" has four hidden properties (i.e., web, name, latitude, and longitude), the node "Customer" has two hidden properties (i.e., ClientLatitude, ClientLongitude), and the relationship "`SERVES`" has one property (i.e., distance).
Despite its simple visual representation, with this model we can examine several statistical aspects.
For example, by using cypher, which is Neo4j's declarative, SQL-like query language for property graphs, the following syntax provides the minimum, the mean, and the maximum distance coverage from restaurants to customers' location.

``` cypher

MATCH (:Restaurant)-[s:SERVES]->(:Customer)
RETURN round(avg(toFloat(s.Distance)), 1) AS avgDistanceMts,
       min(toFloat(s.Distance))           AS minDistanceMts,
       max(toFloat(s.Distance))           AS maxDistanceMts;
```

\backmatter
